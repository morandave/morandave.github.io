<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.lug.ustc.edu.cn/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="">
<link href="https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto&display=swap" rel="stylesheet">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"morandave.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="选择有时候比努力更重要">
<meta property="og:type" content="website">
<meta property="og:title" content="斋">
<meta property="og:url" content="https://morandave.github.io/index.html">
<meta property="og:site_name" content="斋">
<meta property="og:description" content="选择有时候比努力更重要">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="moran">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://morandave.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>斋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">斋</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://morandave.github.io/2024/01/22/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="moran">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="斋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/22/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">激活函数整理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-22 17:09:38 / 修改时间：17:30:17" itemprop="dateCreated datePublished" datetime="2024-01-22T17:09:38+08:00">2024-01-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%94%A8python%E5%AE%9E%E7%8E%B0%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">用python实现深度学习框架</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1
id="关于激活函数的一种解释很有趣">关于激活函数的一种解释（很有趣）</h1>
<p><img src="/images/激活函数的一种解释01.jpg" style="zoom:25%;" /></p>
<p><img src="/images/激活函数的一种解释02.jpg" style="zoom:25%;" /></p>
<p><img src="/images/激活函数的一种解释03.jpg" style="zoom:25%;" /></p>
<h1 id="logistic函数">Logistic函数</h1>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Logistic</span><span class="token punctuation">(</span>Operator<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""
    对向量的分量施加Logistic函数
    """</span>

    <span class="token keyword">def</span> <span class="token function">compute</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        x <span class="token operator">=</span> self<span class="token punctuation">.</span>parents<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value
        <span class="token comment"># 对父节点的每个分量施加Logistic</span>
        self<span class="token punctuation">.</span>value <span class="token operator">=</span> np<span class="token punctuation">.</span>mat<span class="token punctuation">(</span>
            <span class="token number">1.0</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">+</span> np<span class="token punctuation">.</span>power<span class="token punctuation">(</span>np<span class="token punctuation">.</span>e<span class="token punctuation">,</span> np<span class="token punctuation">.</span>where<span class="token punctuation">(</span><span class="token operator">-</span>x <span class="token operator">></span> <span class="token number">1e2</span><span class="token punctuation">,</span> <span class="token number">1e2</span><span class="token punctuation">,</span> <span class="token operator">-</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">get_jacobi</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> np<span class="token punctuation">.</span>diag<span class="token punctuation">(</span>np<span class="token punctuation">.</span>mat<span class="token punctuation">(</span>np<span class="token punctuation">.</span>multiply<span class="token punctuation">(</span>self<span class="token punctuation">.</span>value<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">-</span> self<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>A1<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/images/Logistic函数.png" style="zoom:50%;" /> <span
class="math display">\[
p_1  =\frac{1} { {1 + e^{-x} } }
\]</span></p>
<p><span class="math display">\[
p_2 = \frac{1} { {1 + e^{x} } }
\]</span></p>
<p>p1位于0和1之间，
p2也位于0和1之间，它们的和为1。正如刚才所说，训练会增大正类样本的p1
与负类样本的p2
，这启发我们可以把p1当作正类的概率，把p2当作负类的概率，即把p1和p2当作二分类的概率分布。</p>
<h1 id="双曲正切函数tanh">双曲正切函数（Tanh）</h1>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Tanh</span><span class="token punctuation">(</span>Operator<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""
    对矩阵的元素施加Tanh函数
    """</span>

    <span class="token keyword">def</span> <span class="token function">compute</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>value <span class="token operator">=</span> np<span class="token punctuation">.</span>mat<span class="token punctuation">(</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>power<span class="token punctuation">(</span>np<span class="token punctuation">.</span>e<span class="token punctuation">,</span> np<span class="token punctuation">.</span>where<span class="token punctuation">(</span><span class="token operator">-</span>x <span class="token operator">></span> <span class="token number">1e2</span><span class="token punctuation">,</span> <span class="token number">1e2</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-</span>np<span class="token punctuation">.</span>power<span class="token punctuation">(</span>np<span class="token punctuation">.</span>e<span class="token punctuation">,</span> np<span class="token punctuation">.</span>where<span class="token punctuation">(</span><span class="token operator">-</span>x <span class="token operator">></span> <span class="token number">1e2</span><span class="token punctuation">,</span> <span class="token number">1e2</span><span class="token punctuation">,</span> <span class="token operator">-</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">get_jacobi</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> np<span class="token punctuation">.</span>diag<span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">-</span>self<span class="token punctuation">.</span>compute<span class="token punctuation">(</span>self<span class="token punctuation">.</span>parents<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/images/Tanh函数.png" style="zoom:50%;" /> <span
class="math display">\[
\text{tanh}(x) = \frac{ {e^x - e^{-x} } } { {e^x + e^{-x} } }
\]</span>
双曲正切函数和Logistic函数的图形相似，也是一个呈S形的曲线，不同的是它在负值一侧趋近于
-1，而Logistic函数在负值一侧则趋近于0。 <span class="math display">\[
\frac{ {d} } { {dx} }\left(\text{tanh}(x)\right) = 1 - \text{tanh}^2(x)
\]</span></p>
<h2
id="线性整流单元relurectified-linear-unit">线性整流单元ReLU（Rectified
Linear Unit）</h2>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">ReLU</span><span class="token punctuation">(</span>Operator<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""
    对矩阵的元素施加ReLU函数
    """</span>

    <span class="token keyword">def</span> <span class="token function">compute</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>value <span class="token operator">=</span> np<span class="token punctuation">.</span>mat<span class="token punctuation">(</span>np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>
            self<span class="token punctuation">.</span>parents<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value <span class="token operator">></span> <span class="token number">0.0</span><span class="token punctuation">,</span>
            self<span class="token punctuation">.</span>parents<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value<span class="token punctuation">,</span>
            <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">get_jacobi</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> np<span class="token punctuation">.</span>diag<span class="token punctuation">(</span>np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>self<span class="token punctuation">.</span>parents<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value<span class="token punctuation">.</span>A1 <span class="token operator">></span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/images/ReLU函数.png" style="zoom:50%;" /> <span
class="math display">\[
\text{ReLU}(x) = \max(0, x)
\]</span>
当输入大于0时，ReLU函数的导数是1，即图形在正半轴的斜率是1；当输入小于0时，ReLU函数的导数是0，即图形在负半轴的斜率是0。我们都知道，计算图节点的关键任务是计算子节点对父节点的雅可比矩阵。因此，我们并不希望看到导数为0的情况，因为这样意味着在反向传播时就没有信息向前传递了。对此，人们提出了一种对ReLU函数的修改，称为LeakyReLU：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">ReLU</span><span class="token punctuation">(</span>Operator<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""
    对矩阵的元素施加ReLU函数
    """</span>

    nslope <span class="token operator">=</span> <span class="token number">0.1</span>  <span class="token comment"># 负半轴的斜率</span>

    <span class="token keyword">def</span> <span class="token function">compute</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>value <span class="token operator">=</span> np<span class="token punctuation">.</span>mat<span class="token punctuation">(</span>np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>
            self<span class="token punctuation">.</span>parents<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value <span class="token operator">></span> <span class="token number">0.0</span><span class="token punctuation">,</span>
            self<span class="token punctuation">.</span>parents<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value<span class="token punctuation">,</span>
            self<span class="token punctuation">.</span>nslope <span class="token operator">*</span> self<span class="token punctuation">.</span>parents<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
        <span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">get_jacobi</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> np<span class="token punctuation">.</span>diag<span class="token punctuation">(</span>np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>self<span class="token punctuation">.</span>parents<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value<span class="token punctuation">.</span>A1 <span class="token operator">></span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>nslope<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/images/LeakyReLU.png" style="zoom:50%;" /> <span
class="math display">\[
\text{LeakyReLU}(x) = \begin{cases}
x, &amp; \text{if } x \geq 0 \\
\alpha x, &amp; \text{if } x &lt; 0 \\
\end{cases}
\]</span>
以上是LeakyReLU函数的实现，LeakyReLU函数与ReLU函数的差异是：当输入小于0时，它的输出为输
入的0.1倍。其中的0.1是一个超参数，也可以取其他值。如此，在负半轴，LeakyReLU函数的斜率就是0.1了，这个值虽然很小但是不为0。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://morandave.github.io/2024/01/18/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="moran">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="斋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/18/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E6%B1%87%E6%80%BB/" class="post-title-link" itemprop="url">损失函数汇总</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-18 15:45:06 / 修改时间：18:14:41" itemprop="dateCreated datePublished" datetime="2024-01-18T15:45:06+08:00">2024-01-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/deep-learning-framework/" itemprop="url" rel="index"><span itemprop="name">deep learning framework</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="感知机损失节点">感知机损失节点</h1>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PerceptionLoss</span>(<span class="title class_ inherited__">LossFunction</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    感知机损失，输入为正时为0，输入为负时为输入的相反数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compute</span>(<span class="params">self</span>):</span><br><span class="line">        self.value = np.mat(np.where(</span><br><span class="line">            self.parents[<span class="number">0</span>].value &gt;= <span class="number">0.0</span>, <span class="number">0.0</span>, -self.parents[<span class="number">0</span>].value))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_jacobi</span>(<span class="params">self, parent</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        雅克比矩阵为对角阵，每个对角线元素对应一个父节点元素。若父节点元素大于0，则</span></span><br><span class="line"><span class="string">        相应对角线元素（偏导数）为0，否则为-1。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        diag = np.where(parent.value &gt;= <span class="number">0.0</span>, <span class="number">0.0</span>, -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> np.diag(diag.ravel())</span><br></pre></td></tr></table></figure>
<p><img src="/images/感知机损失函数.png" style="zoom:50%;" /></p>
<center>
感知机损失函数
</center>
<p>感知机损失的图形在原点处有一个硬转折，这意味着它在该点不可导。这个问题其实并不大，因为输入正好落在原点处的概率极低。但是对于大于0的输入来说，其输出值一直为0，这并不太好，虽然此时模型的分类正确，但还是希望它能够“更正确”，即输出值离
轴越远越好。我们想要的结果是让损失值在输入大于0时仍有惩罚，但惩罚较小，而且随着输入越大惩罚越小。</p>
<h1 id="对数损失节点">对数损失节点</h1>
<h2 id="代码实现-1">代码实现</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LogLoss</span>(<span class="title class_ inherited__">LossFunction</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compute</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(self.parents) == <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        x = self.parents[<span class="number">0</span>].value</span><br><span class="line"></span><br><span class="line">        self.value = np.log(<span class="number">1</span> + np.power(np.e, np.where(-x &gt; <span class="number">1e2</span>, <span class="number">1e2</span>, -x)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_jacobi</span>(<span class="params">self, parent</span>):</span><br><span class="line"></span><br><span class="line">        x = parent.value</span><br><span class="line">        diag = -<span class="number">1</span> / (<span class="number">1</span> + np.power(np.e, np.where(x &gt; <span class="number">1e2</span>, <span class="number">1e2</span>, x)))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> np.diag(diag.ravel())</span><br></pre></td></tr></table></figure>
<p><img src="/images/对数损失函数.png" style="zoom:50%;" /></p>
<center>
对数损失的函数图像
</center>
<p><span class="math display">\[
L(X) = log(1+e^{-x})
\]</span></p>
<p>当预测正确时，对数损失的值并不会像感知机损失那样立即消失，而是逐渐消失。这就对“不那么正确”的情况施加了一定的惩罚，催促其对数损失值远离
轴，从而模型分类“更正确”。当预测错误时，对数损失有较大的惩罚且随错误加剧呈线性增长。</p>
<hr />

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://morandave.github.io/2024/01/17/python%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95-%E6%96%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="moran">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="斋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/17/python%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95-%E6%96%AD%E8%A8%80/" class="post-title-link" itemprop="url">python进阶语法--断言</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-17 16:18:23 / 修改时间：16:23:25" itemprop="dateCreated datePublished" datetime="2024-01-17T16:18:23+08:00">2024-01-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="assertion">assertion</h1>
<p>当你在学习Python时遇到关键词
<code>assert</code>，它是用于进行断言检查的关键词。</p>
<p>断言（assertion）是一种在程序中用于检查是否满足某个条件的语句。它用于在代码中标记出一个必须为真的条件，如果条件不满足，那么程序会引发一个断言错误（AssertionError）。</p>
<p><code>assert</code> 语句的一般形式是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> 条件, 错误信息</span><br></pre></td></tr></table></figure>
<p>其中，<code>条件</code>
是一个布尔表达式，表示需要进行检查的条件。如果条件为真，那么程序会继续执行；如果条件为假，那么程序会引发
<code>AssertionError</code> 异常，并输出可选的
<code>错误信息</code>。</p>
<p>断言通常用于在程序中检查一些基本的假设，以确保程序在运行时的关键点上具有期望的状态。如果断言失败，那么说明程序的某些方面出现了问题，需要进行调试和修复。</p>
<p>需要注意的是，在正式发布的程序中，断言通常会被禁用，因为它们会在运行时引发错误。但在开发和调试阶段，断言是非常有用的，可以帮助开发人员捕获潜在的问题和错误。</p>
<p>下面是一个使用 <code>assert</code> 的简单示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">assert</span> b != <span class="number">0</span>, <span class="string">&quot;除数不能为0&quot;</span></span><br><span class="line">    <span class="keyword">return</span> a / b</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(divide(<span class="number">10</span>, <span class="number">2</span>))  <span class="comment"># 正常执行，输出 5.0</span></span><br><span class="line"><span class="built_in">print</span>(divide(<span class="number">10</span>, <span class="number">0</span>))  <span class="comment"># 断言失败，引发 AssertionError，并输出错误信息</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，<code>assert b != 0</code> 用于检查除数
<code>b</code> 是否为零，如果是零，那么会引发断言错误，并输出错误信息
"除数不能为0"。</p>
<h1 id="举个例子">举个例子</h1>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> <span class="built_in">isinstance</span>(target, Node) <span class="keyword">and</span> <span class="built_in">isinstance</span>(graph, Graph)</span><br></pre></td></tr></table></figure>
<p>以上代码的作用是在运行时检查 <code>target</code> 和
<code>graph</code> 对象的类型是否符合预期。</p>
<ul>
<li><code>assert isinstance(target, Node)</code> 用于检查
<code>target</code> 是否是 <code>Node</code> 类型的实例。如果
<code>target</code> 不是 <code>Node</code>
类型的实例，那么断言会失败，引发 <code>AssertionError</code> 异常。</li>
<li><code>assert isinstance(graph, Graph)</code> 用于检查
<code>graph</code> 是否是 <code>Graph</code> 类型的实例。如果
<code>graph</code> 不是 <code>Graph</code>
类型的实例，那么断言会失败，引发 <code>AssertionError</code> 异常。</li>
</ul>
<p>这些断言语句的目的是确保在执行后续的代码之前，<code>target</code> 和
<code>graph</code>
的类型是正确的。如果断言失败，那么说明程序中的某些部分可能存在错误，需要进行调试和修复。</p>
<p>这样的断言检查通常在代码中的关键点或者函数的入口处使用，以确保传入的参数满足预期的类型要求。通过这种方式，可以提前捕获类型错误，加强代码的健壮性和可维护性。</p>
<p>需要注意的是，断言语句在运行时默认是启用的，但可以通过设置 Python
解释器的优化级别或使用命令行参数来禁用它们。因此，在发布程序时，这些断言语句可能会被忽略或删除，以提高性能。</p>
<hr />

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://morandave.github.io/2024/01/17/%E4%BC%98%E5%8C%96%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="moran">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="斋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/17/%E4%BC%98%E5%8C%96%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">优化器类的实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-17 16:04:39" itemprop="dateCreated datePublished" datetime="2024-01-17T16:04:39+08:00">2024-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-18 18:15:06" itemprop="dateModified" datetime="2024-01-18T18:15:06+08:00">2024-01-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/deep-learning-framework/" itemprop="url" rel="index"><span itemprop="name">deep learning framework</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="优化器类的实现">优化器类的实现</h1>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Optimizer</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    优化器基类</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, graph, target, learning_rate=<span class="number">0.01</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        优化器的构造函数接受计算图对象，目标节点对象以及学习率</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">isinstance</span>(target, Node) <span class="keyword">and</span> <span class="built_in">isinstance</span>(graph, Graph)</span><br><span class="line">        self.graph = graph</span><br><span class="line">        self.target = target</span><br><span class="line">        self.learning_rate = learning_rate</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 为每个参与训练的节点累加一个Mini Batch的全部样本的梯度</span></span><br><span class="line">        self.acc_gradient = <span class="built_in">dict</span>()</span><br><span class="line">        self.acc_no = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">one_step</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        计算并累加样本的梯度</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.forward_backward()</span><br><span class="line">        self.acc_no += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_gradient</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        返回样本的平均梯度</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">assert</span> node <span class="keyword">in</span> self.acc_gradient</span><br><span class="line">        <span class="keyword">return</span> self.acc_gradient[node] / self.acc_no</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_update</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        抽象方法，执行具体的梯度更新算法，由子类实现</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">apply_gradients</span>(<span class="params">self, node_gradients_dict, summarize=<span class="literal">False</span>, acc_no=<span class="literal">None</span></span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> node, gradient <span class="keyword">in</span> node_gradients_dict.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(node, Node):</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                target_node = get_node_from_graph(node)</span><br><span class="line">                <span class="keyword">assert</span> target_node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line">                <span class="keyword">assert</span> self.acc_gradient[target_node].shape == gradient.shape</span><br><span class="line">                <span class="keyword">if</span> summarize:</span><br><span class="line">                    self.acc_gradient[target_node] += gradient</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.acc_gradient[target_node] = gradient</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> summarize:</span><br><span class="line">            self.acc_no += acc_no</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> acc_no <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="comment"># 传入的是平均梯度, 强制让acc_no变为1，避免梯度更新时重复平均</span></span><br><span class="line">                self.acc_no = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.acc_no = acc_no</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, var_gradients=<span class="literal">None</span></span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> var_gradients <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.apply_gradients(var_gradients)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 执行更新</span></span><br><span class="line">        self._update()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 清除累加梯度</span></span><br><span class="line">        self.acc_gradient.clear()</span><br><span class="line">        self.acc_no = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward_backward</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        前向传播计算结果节点的值并反向传播计算结果节点对各个节点的雅可比矩阵</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 清除计算图中所有节点的雅可比矩阵</span></span><br><span class="line">        self.graph.clear_jacobi()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 前向传播计算结果节点</span></span><br><span class="line">        self.target.forward()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 反向传播计算雅可比矩阵</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.graph.nodes:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(node, Variable) <span class="keyword">and</span> node.trainable:</span><br><span class="line">                node.backward(self.target)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 最终结果（标量）对节点值的雅可比是一个行向量，其转置是梯度（列向量）</span></span><br><span class="line">                <span class="comment"># 这里将梯度reshape成与节点值相同的形状，好对节点值进行更新。</span></span><br><span class="line">                gradient = node.jacobi.T.reshape(node.shape())</span><br><span class="line">                <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> self.acc_gradient:</span><br><span class="line">                    self.acc_gradient[node] = gradient</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.acc_gradient[node] += gradient</span><br></pre></td></tr></table></figure>
<p><code>Optimizer</code>类的构造函数接受一个<code>Graph</code>类对象和一个目标节点对象（一般是损失值节点），即视作结果的节点（为了简单起见，MatrixSlow框架只支持优化一个目标节点）作为参数。对于机器学习模型的训练来说，就是取损失值节点作为目标节点。<code>learning_rate</code>参数用来指定学习率。<code>Optimizer</code>类的<code>acc_gradient</code>属性是一个字典，将来它会以变量节点对象为key，累加目标节点对该变量节点的梯度。<code>acc_no</code>属性是一个计数器。这两个属性的作用是什么？后面讲解各种梯度下降法的变体时自会明了。</p>
<p><code>one_step</code>方法是优化器类的<strong>执行入口</strong>，它的实现很简单：先调用<code>forward_backward</code>方法，再将<code>acc_no</code>计数器加一。<code>forward_backward</code>方法抽象了优化过程的前两步，从它的名字就可以看出，它完成的是一次前向传播和反向传播。这个方法先调用目标节点的<code>forward</code>方法完成前向传播，然后再遍历计算图中的所有节点，找出其中类型是<code>Variable</code>且参加训练的节点，依次调用这些节点的<code>backward</code>方法执行反向传播，从而计算出目标节点对它们的雅
可比矩阵。将雅可比矩阵转置后就是目标节点对某变量节点的梯度，再将梯度变形并累加到<code>acc_gradient</code>中。</p>
<p><code>update</code>方法封装了优化过程的第三步：参数更新。在<code>Optimizer</code>类中，<code>update</code>方法调用的是<code>_update</code>抽象方法。<code>_update</code>方法由具体的优化器子类覆盖实现。执行完<code>_update</code>方法后，清空累加器<code>acc_gradient</code>并将<code>acc_no</code>计数器也清零。<code>get_gradient</code>是一个辅助性的方法，它返回的是当前梯度累加器的平均梯度。</p>
<blockquote>
<p>在Python中，方法名前面加下划线（_）的约定被称为命名约定。这种约定通常用于指示方法或属性是供内部使用的，或者是一种特殊的行为。</p>
<p>当一个方法名以单个下划线开头时（例如<code>_update</code>），这是一种暗示，表示该方法是类的内部方法，供类的其他方法使用，但不鼓励直接从外部调用。它可以被视为一种私有方法的约定，尽管在Python中并没有严格的私有方法的概念。这种命名约定的目的是提示其他开发者该方法是类内部实现的一部分，不建议在类外部直接调用。</p>
<p>下划线开头的方法名还可以用于避免命名冲突。当你有一个公共方法名（例如<code>update</code>），但同时又需要在类的内部使用一个类似的方法名时，可以使用下划线作为前缀来区分它们（例如<code>_update</code>）。这样做可以避免在外部使用时意外调用了一个内部方法。</p>
<p>需要注意的是，这种命名约定并不会阻止你从外部直接调用带下划线的方法，但它是一种提示和约定，让其他开发者知道哪些方法是预期仅在类内部使用的。</p>
<p>总之，当你看到一个方法名前面加下划线时，它表示这是一个类的内部方法或有特殊用途的方法，建议只在类内部使用或按照作者的说明来使用。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只用以下一行代码就可以实现前向传播和反向传播</span></span><br><span class="line">optimizer.one_step()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以前的代码，可以发现一个问题，如果参数很多的话backward()需要调用很多遍</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在loss节点上执行前向传播，计算损失值</span></span><br><span class="line">loss.forward()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在w和b节点上执行反向传播，计算损失值对它们的雅可比矩阵</span></span><br><span class="line">w.backward(loss)</span><br><span class="line">b.backward(loss)</span><br></pre></td></tr></table></figure>
<hr />

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://morandave.github.io/2024/01/16/%E5%86%99%E7%BB%99wxy%E7%9A%84python%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="moran">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="斋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/16/%E5%86%99%E7%BB%99wxy%E7%9A%84python%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B2/" class="post-title-link" itemprop="url">写给wxy的python入门教程（二）——基本语法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-16 15:43:36" itemprop="dateCreated datePublished" datetime="2024-01-16T15:43:36+08:00">2024-01-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-21 21:55:31" itemprop="dateModified" datetime="2024-01-21T21:55:31+08:00">2024-01-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>关键词：变量 数据类型 函数 逻辑语句</strong></p>
<h1 id="helloworld">Hello,world</h1>
<p>学习任何编程语言的第一步（搭好编程环境后）一定是尝试输出Hello
world，它可以验证编程环境是否搭建完成，同时也是学习一门编程语言语法开始的地方。python的Hello
world程序如下：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello world!"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>非常简洁，只有一行代码，即可实现在终端输出Hello world!</p>
<p>这个程序实际上只有一行，使用了一个<strong>函数</strong>：print(),函数是编程中一个非常重要的概念，我们先将这个概念放一放，现阶段只需要知道print()函数的作用是将括号内的东西打印到终端。（不知道你懂不懂“打印到终端什么意思，不懂到时候记得问”）</p>
<h1 id="变量">变量</h1>
<p><strong>变量</strong>，一个编程中和<strong>函数</strong>同样重要的概念。变量变量，重点在于会变，你只要命名了一个变量，就可以给它赋上任何值（python里是这样，其他编程语言并非如此）。变量是由你创造出来的事物，你想让它是什么就是什么（你可以随时改变它的值）。但是呢，也不是那么随意的，你不能直接用“x=人”这句代码来让x代表一个人，实际上确实有方法来让x代表一个人，但是那需要一些更高级的语法，而更高级的语法是由低级语法一步步扩展得到的，下面我们来看看低级语法是什么样的，看看x在最低层级上可以表达什么，<strong>有哪些东西是最基础的，可以用这些基础的东西来逐步表示诸如“人”这样的高级概念</strong>。</p>
<p>到这里停一下，请聪明的你动动脑筋，可能会有哪些“基础变量”，提示一个思路：需要表示一个人需要哪些东西？人有年龄、性别、姓名、身高等等属性，要表示这些东西需要哪些东西来描述它们呢？</p>
<h2 id="数字">数字</h2>
<p>聪明的你应该想到了，是数字，数字是描述这个世界必不可少的工具，编程语言要想描述这个世界也需要数字。python中对于数字的处理做的非常好。你只需要像做数学题一样把计算过程写出来就可以使用数字了，举个例子：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">x <span class="token operator">=</span> <span class="token number">5</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> 

y <span class="token operator">=</span> <span class="token number">3.14</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span>  

height <span class="token operator">=</span> <span class="token number">5</span>
weight <span class="token operator">=</span> <span class="token number">2</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>height <span class="token operator">+</span> weight<span class="token punctuation">)</span>  <span class="token comment"># 加法</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>height <span class="token operator">-</span> weight<span class="token punctuation">)</span>  <span class="token comment"># 减法</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>height <span class="token operator">*</span> weight<span class="token punctuation">)</span>  <span class="token comment"># 乘法</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>height <span class="token operator">/</span> weight<span class="token punctuation">)</span>  <span class="token comment"># 除法</span>


x <span class="token operator">=</span> <span class="token number">2</span>
y <span class="token operator">=</span> <span class="token number">3</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>x <span class="token operator">**</span> y<span class="token punctuation">)</span>  <span class="token comment"># 幂运算，2的3次方是8</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">%</span> b<span class="token punctuation">)</span>   <span class="token comment"># 取余运算，2除以3的余数为2</span>

BMI <span class="token operator">=</span> weight<span class="token operator">/</span><span class="token punctuation">(</span>height<span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>BMI<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面就是一些基本的python数字运算啦你可能会好奇，为什么要单独举个例子“y
=
3.14”，实际上，小数在编程语言中有个专门的概念叫<strong>浮点数</strong>，至于为什么叫浮点数，这个涉及到计算机底层的知识，如果你感兴趣的单独问我。浮点数在其他编程语言中会有明细的划分，但在python中，你只需要把它和整数当成一个概念就行，当成数字来用就ok。</p>
<p>你应该注意到了，朱老师上面用了<code>weight</code>和<code>height</code>这两个变量名，朱老师是怕你产生一个一个误解，认为变量的名字只能用x、y这种字母，实际上，变量名的作用是方便编程人员的阅读，所以变量名设计的原则就是要一眼可以读懂变量所代表的东西，比如使用了weight这个变量名，那么别人一看到就知道，这个变量中存的是体重，那么这个weight中存的应该是数字，而不是其他东西。</p>
<p>像“+-
*/”这些东西在python中称为<strong>运算符</strong>，顾名思义，是用来运算的，配合着数字变量使用就可以实现算数运算。</p>
<h3 id="有关数字的小练习">有关数字的小练习</h3>
<p>海伦公式是由古希腊数学家海伦（Heron）提出的，用于计算三角形的面积。海伦公式可以表示为：</p>
<p><span class="math display">\[
A = \sqrt{s(s-a)(s-b)(s-c)}
\]</span> 其中，A表示三角形的面积，a、b 和
c分别表示三角形的三条边的长度，s表示半周长，即三角形的三条边的和的一半。海伦公式提供了一种计算任意三角形面积的方法，而不需要知道三角形的高度或底边。这使得海伦公式在实际应用中非常有用，特别是当我们只知道三角形的三个边长时。</p>
<p>请你写一个python文件area.py。要求实现功能：输入三角形的三条边长，在终端输出三角形的面积（已知输入的三边一定可以构成三角形）</p>
<blockquote>
<p>提示：如何在终端输入一个数字并将这个数字赋值给某一变量呢？</p>
</blockquote>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">a<span class="token operator">=</span><span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入a的值："</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>上述代码将会在终端产生“请输入一个数字：”这句话，你只需要在这句话的后面输入一个数字，再按一下回车键，就可以让a被赋值。比如，你输入6，再按回车键，这样a就被赋值6，聪明的你应该感觉到了，这样的话实际上等价于运行
<code>a = 6</code> 这句代码。朱老师怕你还不懂，那么试试以下代码吧：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">a<span class="token operator">=</span><span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入a的值："</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<blockquote>
<p>开根号运算如何实现</p>
</blockquote>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 开根号运算</span>
result <span class="token operator">=</span> <span class="token number">16</span> <span class="token operator">**</span> <span class="token number">0.5</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>  <span class="token comment"># 输出：4.0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="字符串">字符串</h2>
<p>那除了数字还有什么呢，是“文字”，我们需要用文字来描述这个世界。在Python中使用<strong>字符串</strong>来达到文字的作用，用引号括起的都是字符串，其中的引号可以是单引号，也可以是双引号</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token string">"This is a string."</span>
<span class="token string">'This is also a string.'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="变量的命名与使用">变量的命名与使用</h2>
<p>在Python中，变量的命名需要遵循一定的规则，只要不违反这个规则，随你怎么命名：</p>
<ol type="1">
<li>变量名只能包含<em>字母</em>（大小写均可）、<em>数字</em>和<em>下划线</em>（_），不能包含空格或其他特殊字符。</li>
<li>变量名不能以数字开头，但可以在开头包含下划线。</li>
<li>变量名区分大小写，例如"<code>myVariable</code>"和"<code>myvariable</code>"是两个不同的变量。</li>
<li>避免使用Python关键字和内置函数名作为变量名，这样可以避免与Python的语法冲突。例如，不要使用"<code>print</code>"等作为变量名。</li>
</ol>
<p>以上是一些python命名的硬规则（不能违反，违反就会出错），下面是一些增强代码可读性的建议：</p>
<ol type="1">
<li>变量名应该具有描述性，能够清楚地表达变量的含义。这样可以提高代码的可读性和可维护性。（不要再用简单的x、y了哦）。</li>
<li>通常使用小写字母和下划线的组合来命名变量，例如"<code>my_variable</code>"。通过下划线将单词分开。</li>
<li>对于常量（不会被修改的变量），通常使用全大写字母和下划线的组合来命名，例如"PI"（圆周率π）。</li>
</ol>
<p>需要注意的是，虽然Python对变量名的长度没有明确限制，但为了代码可读性，建议使用简洁而有意义的变量名。比如要用一个变量存储长度，可以不用<code>length</code>整个单词，用<code>len</code>三个字母也行。</p>
<h1 id="逻辑语句">逻辑语句</h1>
<h2 id="if语句">if语句</h2>
<p>还记得之前写过的求三角形面积的小作业吗，当时朱老师留下了一个疑问：如果程序输入的三条边无法构成三角形怎么办（有可能输入的是负数，也有可能输入的三个正数不能构成三角形）？接下来朱老师将会告诉你处理办法，首先我们来思考一下之前的代码是怎么执行的，是一行一行执行的，如果前面一行的代码报错了，那么程序将会终止，你所写的程序运行完指的就是你写的x行代码全部运行完成。那么这就产生一个问题，为什么一定要运行所有的代码呢，我为什么不能<strong>有选择地运行</strong>我想运行的代码呢，我其实可以做一个检查，检查到三条边不能构成三角形就直接停止程序。那么接下来我们就让if语句隆重登场。我们还是用求三角形面积这个例子</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入a的值："</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
b <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入b的值："</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
c <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入c的值："</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment"># 检查是否可以构成三角形</span>
<span class="token keyword">if</span> a<span class="token operator">&lt;=</span><span class="token number">0</span> <span class="token keyword">or</span> b<span class="token operator">&lt;=</span><span class="token number">0</span> <span class="token keyword">or</span> c<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"请输入正数"</span><span class="token punctuation">)</span>
<span class="token keyword">elif</span> a <span class="token operator">+</span> b <span class="token operator">></span> c <span class="token keyword">and</span> a <span class="token operator">+</span> c <span class="token operator">></span> b <span class="token keyword">and</span> b <span class="token operator">+</span> c <span class="token operator">></span> a<span class="token punctuation">:</span>
    <span class="token comment"># 可以构成三角形</span>
    s <span class="token operator">=</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.5</span>
    d <span class="token operator">=</span> s <span class="token operator">*</span> <span class="token punctuation">(</span>s <span class="token operator">-</span> a<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>s <span class="token operator">-</span> b<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>s <span class="token operator">-</span> c<span class="token punctuation">)</span>
    result <span class="token operator">=</span> d <span class="token operator">**</span> <span class="token number">0.5</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"输入的三条边不能构成三角形"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>让我们来详细讲讲以上代码：（首先说一句，我接下来所说的“<strong>if</strong>语句”包括上面代码中的<code>if</code>、<code>elif</code>和<code>else</code>）</p>
<p>我们先抓住重点：<strong>if语句的作用是按照<em>一定的条件</em>运行我们<em>想要程序运行的代码</em>。</strong></p>
<p>上面这句话其实隐藏着一个点，那就是：一个条件对应一段代码，当满足一个条件时，就会执行一段代码。</p>
<p>那么在三角形判断这个问题中会出现三种情况，每种情况对应执行不同的代码：</p>
<ol type="1">
<li>输入的边中有负数 ——》 输出“请输入正数”</li>
<li>输入的三条边可以构成三角形 ——》 使用海伦公式计算面积</li>
<li>输入的三条边虽然是正数但无法构成三角形 ——》
输出“输入的三条边不能构成三角形”</li>
</ol>
<p>首先要说明一下<code>if</code>、<code>elif</code>和<code>else</code>的含义：三者中的<code>if</code>、<code>elif</code>后面都需要跟判断条件，一旦条件满足就会执行相应的代码，需要知道的是，<code>if</code>一定在<code>elif</code>之前，且只可以有一个<code>if</code>，而<code>elif</code>可以有<em>无数个</em>，而<code>else</code>一定在最后且只有一个，只有当前面的if<code>、</code>elif的条件都没有被满足时，<code>else</code>的对应代码才会被执行，也因此<code>else</code>的后面不需要加判断条件。请注意，所有的<code>if</code>、<code>elif</code>和<code>else</code>后面都需要加冒号。还有一点：那就是无论有多少个<code>elif</code>加上一个if和else，<strong>只会执行一个代码段</strong>，举个例子，如果在某个elif处条件被满足了，那么无论后面的elif的条件是否满足都不会再执行了。</p>
<p>我们来看每个条件怎么表示：</p>
<p>1.输入的三条边可以构成三角形：<code>a + b &gt; c and a + c &gt; b and b + c &gt; a</code></p>
<p>这个条件的表示中<code>a + b &gt; c</code>你应该可以看懂，其实<code>a + b &gt; c</code>本身就是一个<strong>子条件</strong>，就是这个<code>and</code>会不懂，其实很简单，用<code>and</code>可以将不同的条件连接起来，也就是说，只有当<code>and</code>连接的所有子条件<strong>都满足</strong>了，这个<code>if</code>后面的<strong>大条件</strong>才算被满足。举个例子：输入的三角形的三条边为1、2、3，分别为a、b、c，<code>b+c&gt;a</code>的条件满足了，但是呢<code>a + b &gt; c</code>并没有被满足，所以与if对应的代码不会被执行。</p>
<p>2.输入的边中有负数：<code>a&lt;=0 or b&lt;=0 or c&lt;=0</code>（请注意小于/大于等于需用&lt;=/&gt;=，没有单独的一个符号表示小于/大于等于）</p>
<p>与<code>and</code>不同，<code>or</code>没有那么苛刻，只要用<code>or</code>连接的子条件中的<strong>任意一个</strong>被满足了，那么这整个大条件都被满足了，在这个例子中，只要这三条边中的任意一个小于等于0了，<code>elif</code>就会被触发</p>
<p>聪明的你会注意到，上面的代码我中有一些行被我“往后面”移动了，这个“移动”呢叫做：<strong>缩进</strong>。缩进也是python语法的一部分，<strong>如何体现某几行代码属于某个<code>if</code>语句</strong>呢，那就是看它后面那几行代码缩进了，这个缩进的长度是固定的：四个空格，也就是一个Tab键（键盘的左上方附近）。</p>
<h1 id="函数">函数</h1>
<hr />

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://morandave.github.io/2024/01/16/%E4%BB%8EAdaline%E5%88%B0%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="moran">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="斋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/16/%E4%BB%8EAdaline%E5%88%B0%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">从Adaline到逻辑回归模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-16 11:16:48" itemprop="dateCreated datePublished" datetime="2024-01-16T11:16:48+08:00">2024-01-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-19 10:02:35" itemprop="dateModified" datetime="2024-01-19T10:02:35+08:00">2024-01-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/deep-learning-framework/" itemprop="url" rel="index"><span itemprop="name">deep learning framework</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算图的搭建">计算图的搭建</h1>
<p>先上代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构造计算图：输入向量，是一个3x1矩阵，不需要初始化，不参与训练</span></span><br><span class="line">x = ms.core.Variable(dim=(<span class="number">3</span>, <span class="number">1</span>), init=<span class="literal">False</span>, trainable=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类别标签，1男，-1女</span></span><br><span class="line">label = ms.core.Variable(dim=(<span class="number">1</span>, <span class="number">1</span>), init=<span class="literal">False</span>, trainable=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 权重向量，是一个1x3矩阵，需要初始化，参与训练</span></span><br><span class="line">w = ms.core.Variable(dim=(<span class="number">1</span>, <span class="number">3</span>), init=<span class="literal">True</span>, trainable=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 阈值，是一个1x1矩阵，需要初始化，参与训练</span></span><br><span class="line">b = ms.core.Variable(dim=(<span class="number">1</span>, <span class="number">1</span>), init=<span class="literal">True</span>, trainable=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ADALINE的预测输出(计算图在此搭建)</span></span><br><span class="line"><span class="comment"># 参与计算的变量是计算节点的父节点  这句代码的作用是双向的，w,x成为MatMul的父节点的同时，MatMul成为w，b的子节点</span></span><br><span class="line">output = ms.ops.Add(ms.ops.MatMul(w, x), b)</span><br><span class="line">predict = ms.ops.Step(output)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 损失函数(也是节点类子类)</span></span><br><span class="line">loss = ms.ops.loss.PerceptionLoss(ms.ops.MatMul(label, output))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在loss节点上执行前向传播，计算损失值</span></span><br><span class="line">loss.forward()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在w和b节点上执行反向传播，计算损失值对它们的雅可比矩阵</span></span><br><span class="line">w.backward(loss)</span><br><span class="line">b.backward(loss)</span><br></pre></td></tr></table></figure>
<p>我们来debug以上的正向传播与反向传播过程：</p>
<p><img src="/images/正向传播过程1.png" /></p>
<p>以第一次递归为例，父节点为<code>MatMul</code>，子节点为<code>PerceptionLoss</code>，接下来，self和node将不断往前更替，如图：</p>
<p><img src="/images/debug图.png" /></p>
<p>计算图由算子之间的父子关系来组成。计算图中的边由算子的<code>parents</code>和<code>children</code>来实现</p>
<p>无论backward递归到哪一层，结果节点loss是不变的</p>
<p><img src="/images/Adaline.png" /></p>
<h1 id="用到的算子">用到的算子</h1>
<p>首先，在<a
href="https://morandave.github.io/2023/11/30/%E8%8A%82%E7%82%B9%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/">《节点类的实现》</a>中我们提到过继承自<code>Node</code>类的算子需要实现<code>compute</code>和<code>get_jacobi(parent)</code>这两个函数，这两个函数体现了算子的性质。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;加法算子&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Add</span>(<span class="title class_ inherited__">Operator</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    （多个）矩阵加法</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compute</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># assert len(self.parents) == 2 and self.parents[0].shape() == self.parents[1].shape()</span></span><br><span class="line">        self.value = np.mat(np.zeros(self.parents[<span class="number">0</span>].shape()))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> parent <span class="keyword">in</span> self.parents:</span><br><span class="line">            self.value += parent.value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_jacobi</span>(<span class="params">self, parent</span>):</span><br><span class="line">        <span class="keyword">return</span> np.mat(np.eye(self.dimension()))  <span class="comment"># 矩阵之和对其中任一个矩阵的雅可比矩阵是单位矩阵</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MatMul</span>(<span class="title class_ inherited__">Operator</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    矩阵乘法</span></span><br><span class="line"><span class="string">    MatMul类继承Operator类。Operator类继承Node类，它什么也没做，只起整理类继承结构的作用</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compute</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        先判断两个父节点的值（矩阵）的形状是否可以相乘，即第一个父节点的列数是否等于第二个父节点的行数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(self.parents) == <span class="number">2</span> <span class="keyword">and</span> self.parents[<span class="number">0</span>].shape()[</span><br><span class="line">            <span class="number">1</span>] == self.parents[<span class="number">1</span>].shape()[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 节点值都是Numpy的Matrix类，乘法运算符（*）被重载为矩阵乘法</span></span><br><span class="line">        self.value = self.parents[<span class="number">0</span>].value * self.parents[<span class="number">1</span>].value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_jacobi</span>(<span class="params">self, parent</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        将矩阵乘法视作映射，求映射对参与计算的矩阵的雅克比矩阵。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 很神秘，靠注释说不明白了</span></span><br><span class="line">        <span class="comment"># get_jacobi方法接受一个父节点，返回 节点对这个父节点的雅可比矩阵。原理上较为简单，但实现上涉及元素的排列，稍烦琐些。</span></span><br><span class="line">        zeros = np.mat(np.zeros((self.dimension(), parent.dimension())))</span><br><span class="line">        <span class="keyword">if</span> parent <span class="keyword">is</span> self.parents[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> fill_diagonal(zeros, self.parents[<span class="number">1</span>].value.T)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            jacobi = fill_diagonal(zeros, self.parents[<span class="number">0</span>].value)</span><br><span class="line">            row_sort = np.arange(self.dimension()).reshape(</span><br><span class="line">                self.shape()[::-<span class="number">1</span>]).T.ravel()</span><br><span class="line">            col_sort = np.arange(parent.dimension()).reshape(</span><br><span class="line">                parent.shape()[::-<span class="number">1</span>]).T.ravel()</span><br><span class="line">            <span class="keyword">return</span> jacobi[row_sort, :][:, col_sort]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PerceptionLoss</span>(<span class="title class_ inherited__">LossFunction</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    感知机损失，输入为正时为0，输入为负时为输入的相反数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">	<span class="comment"># 创建一个与self.parents[0].value形状相同的矩阵，其中大于等于0.0的元素被替换为0.0，小于0.0的元素保持不变。最后，将结果赋值给self.value</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compute</span>(<span class="params">self</span>):</span><br><span class="line">        self.value = np.mat(np.where(</span><br><span class="line">            self.parents[<span class="number">0</span>].value &gt;= <span class="number">0.0</span>, <span class="number">0.0</span>, -self.parents[<span class="number">0</span>].value))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_jacobi</span>(<span class="params">self, parent</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        雅克比矩阵为对角阵，每个对角线元素对应一个父节点元素。若父节点元素大于0，则</span></span><br><span class="line"><span class="string">        相应对角线元素（偏导数）为0，否则为-1。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        diag = np.where(parent.value &gt;= <span class="number">0.0</span>, <span class="number">0.0</span>, -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> np.diag(diag.ravel())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="用到的函数">用到的函数</h3>
<ol type="1">
<li><code>np.diag()</code></li>
<li><code>np.where()</code></li>
<li><code>Array.ravel()</code></li>
</ol>
<p>如果<code>parent.value</code>是一个矩阵类型，那么让我们来分析代码的数据类型变化过程：</p>
<ol type="1">
<li><code>diag = np.where(parent.value &gt;= 0.0, 0.0, -1)</code>：
<ul>
<li><code>parent.value</code>是一个矩阵类型。</li>
<li><code>np.where()</code>函数返回一个与<code>parent.value</code>相同形状的矩阵，其中大于等于0.0的元素被替换为0.0，小于0.0的元素被替换为-1。</li>
<li>因此，<code>diag</code>是一个与<code>parent.value</code>相同形状的矩阵，元素的数据类型可能是浮点型或整型，具体取决于<code>parent.value</code>的数据类型。</li>
</ul></li>
<li><code>diag.ravel()</code>：
<ul>
<li><code>diag</code>是一个矩阵类型。</li>
<li><code>ravel()</code>方法将<code>diag</code>展平为一个一维数组。</li>
<li>这意味着，<code>diag.ravel()</code>返回一个一维NumPy数组，其中元素的数据类型与<code>diag</code>相同。</li>
</ul></li>
<li><code>np.diag(diag.ravel())</code>：
<ul>
<li><code>diag.ravel()</code>返回一个一维NumPy数组。</li>
<li><code>np.diag()</code>函数接受一个一维数组作为输入，并返回一个以该一维数组为对角线元素的对角矩阵。</li>
<li>因此，<code>np.diag(diag.ravel())</code>返回一个矩阵，它是以<code>diag.ravel()</code>作为对角线元素的对角矩阵。</li>
<li>返回的对角矩阵的数据类型与输入一维数组的数据类型相同。</li>
</ul></li>
</ol>
<h1 id="logistic函数">Logistic函数</h1>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logistic</span>(<span class="title class_ inherited__">Operator</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    对向量的分量施加Logistic函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compute</span>(<span class="params">self</span>):</span><br><span class="line">        x = self.parents[<span class="number">0</span>].value</span><br><span class="line">        <span class="comment"># 对父节点的每个分量施加Logistic</span></span><br><span class="line">        self.value = np.mat(</span><br><span class="line">            <span class="number">1.0</span> / (<span class="number">1.0</span> + np.power(np.e, np.where(-x &gt; <span class="number">1e2</span>, <span class="number">1e2</span>, -x))))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_jacobi</span>(<span class="params">self, parent</span>):</span><br><span class="line">        <span class="keyword">return</span> np.diag(np.mat(np.multiply(self.value, <span class="number">1</span> - self.value)).A1)</span><br></pre></td></tr></table></figure>
<p><img src="/images/Logistic函数.png" style="zoom:50%;" /> <span
class="math display">\[
p_1  =\frac{1} { {1 + e^{-x} } }
\]</span></p>
<p><span class="math display">\[
p_2 = \frac{1} { {1 + e^{x} } }
\]</span></p>
<p>p1位于0和1之间，
p2也位于0和1之间，它们的和为1。正如刚才所说，训练会增大正类样本的p1
与负类样本的p2
，这启发我们可以把p1当作正类的概率，把p2当作负类的概率，即把p1和p2当作二分类的概率分布。</p>
<h1 id="二分类逻辑回归">二分类逻辑回归</h1>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构造计算图：输入向量，是一个3x1矩阵，不需要初始化，不参与训练</span></span><br><span class="line">x = ms.core.Variable(dim=(<span class="number">3</span>, <span class="number">1</span>), init=<span class="literal">False</span>, trainable=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类别标签，1男，-1女</span></span><br><span class="line">label = ms.core.Variable(dim=(<span class="number">1</span>, <span class="number">1</span>), init=<span class="literal">False</span>, trainable=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 权值向量，是一个1x3矩阵，需要初始化，参与训练</span></span><br><span class="line">w = ms.core.Variable(dim=(<span class="number">1</span>, <span class="number">3</span>), init=<span class="literal">True</span>, trainable=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 偏置，是一个1x1矩阵，需要初始化，参与训练</span></span><br><span class="line">b = ms.core.Variable(dim=(<span class="number">1</span>, <span class="number">1</span>), init=<span class="literal">True</span>, trainable=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测输出</span></span><br><span class="line">output = ms.ops.Add(ms.ops.MatMul(w, x), b)</span><br><span class="line">predict = ms.ops.Logistic(output)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对数损失</span></span><br><span class="line">loss = ms.ops.loss.LogLoss(ms.ops.Multiply(label, output))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 学习率</span></span><br><span class="line">learning_rate = <span class="number">0.0001</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造Adam优化器</span></span><br><span class="line">optimizer = ms.optimizer.Adam(ms.default_graph, loss, learning_rate)</span><br></pre></td></tr></table></figure>
<p>将ADALINE模型的阶跃函数替换为Logistic函数，并对其线性部分施加对数损失，就得到了逻辑回归模型。</p>
<hr />

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://morandave.github.io/2024/01/13/python%E7%9A%84%E5%AF%BC%E5%85%A5%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="moran">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="斋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/13/python%E7%9A%84%E5%AF%BC%E5%85%A5%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">python的导入机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-13 10:56:11" itemprop="dateCreated datePublished" datetime="2024-01-13T10:56:11+08:00">2024-01-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-17 16:23:16" itemprop="dateModified" datetime="2024-01-17T16:23:16+08:00">2024-01-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>关键词：moudule package library</strong></p>
<h1 id="init__文件">__init__文件</h1>
<p>对于一个python项目，里面的每一个文件夹都可以认为是一个package，而每一个.py文件被认为是一个module。如果你用的IDE是PyCharm，那么当你新建一个Python
Package的时候，PyCharm都会自动为你新建一个__init__.py文件。这个__init__.py文件可以看作这个package的初始化文件。</p>
<p>**当我们从一个package里面调用东西的时候，该__init__.py文件内的代码会被首先执行。**</p>
<p>init可以控制包中代码的封装程度，什么可以被外界访问，什么不可以由__init__.py来掌控。</p>
<p>.代表当前所处package</p>
<h1 id="python项目中导入机制的使用">python项目中导入机制的使用</h1>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">library</span><br><span class="line">├── package1</span><br><span class="line">|   ├── __init__.py</span><br><span class="line">|   ├── module1.py</span><br><span class="line">├── package2</span><br><span class="line">|   ├── __init__.py</span><br><span class="line">|   ├── module1.py</span><br><span class="line">├── __init__.py</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">library.init.py</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> package1</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> package2</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">package1.__init__.py</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">from .module1 import *</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">package2.__init__.py</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">from .module1 import *</span><br></pre></td></tr></table></figure>
<hr />

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://morandave.github.io/2024/01/12/%E5%86%99%E7%BB%99wxy%E7%9A%84python%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="moran">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="斋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/12/%E5%86%99%E7%BB%99wxy%E7%9A%84python%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B1/" class="post-title-link" itemprop="url">写给wxy的python入门教程（一）——环境搭建</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-12 10:43:55" itemprop="dateCreated datePublished" datetime="2024-01-12T10:43:55+08:00">2024-01-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-18 17:57:07" itemprop="dateModified" datetime="2024-01-18T17:57:07+08:00">2024-01-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="编程语言运行环境">编程语言运行环境</h1>
<p>无论是谁，想要学习一门<strong>编程语言</strong>，第一步都是在自己的计算机上搭建这门编程语言的<strong>运行环境</strong>。虽说用了搭建这个词，听起来似乎非常复杂，非常的高大上，但实际上不过是下载了一些初学者不太懂的东西，不妨把它理解为一个个软件。那么所谓的搭建编程语言运行环境就可以简单理解为在你的计算机里下载了几个软件，仅此而已。</p>
<h2
id="为什么需要有编程语言运行环境">为什么需要有编程语言运行环境？</h2>
<p>这个问题涉及到一个基本的知识：计算机只能运行<strong>01二进制码</strong>。这句话的基本解释是，你在电脑中的任何操作，如鼠标点击一下、打开某个软件等等实际上都是你的电脑在运行一段01二进制码。或许有点难懂，但我们可以用初高中函数的思想来简单化这个概念：
<span class="math display">\[
f(电脑操作)=一段01二进制码
\]</span>
比如你用计算器计算1+2，会对应着电脑运行00101011这段01二进制代码（举个例子）。这样一个函数关系就形成了，电脑操作是自变量，01二进制代码是应变量。</p>
<p>为什么要说上面这么多东西呢，因为实际上<strong>电脑操作</strong>和<strong>编程语言</strong>是等价的，在计算器这个软件中可以计算1+2，也可以使用python编程语言实现计算1+2，在python代码中一行就可以实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span> + <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>运行以上python代码的结果就是x这个<strong>变量</strong>被赋上了3这个数字值（之后介绍python语法的时候再详细介绍）。也就是说编程语言=电脑操作，那么之前的那个函数就可以修改为：
<span class="math display">\[
f(编程语言代码)=一段01二进制码
\]</span>
敲黑板~~(接下来是重点)：编程语言运行环境就是函数f，编程语言运行环境起到了将编程运行代码转化为01二进制代码的功能。<strong>有了编程语言运行环境你的电脑才可以运行代码</strong>（说了这么多其实总结起来就这一句话）。</p>
<h2 id="实操开始搭建python运行环境">实操：开始搭建python运行环境</h2>
<h3 id="ananconda">Ananconda</h3>
<p>Ananconda是python环境搭建中一个绕不开的工具，解释Anaconda的重要性就需要理解软件的<strong>版本</strong>这一概念。听起来是一个很高级的概念，确实很高级，但也很容易懂。举个例子：朱老师要做两个用python写的项目，一是给小学生做一个计算器，二是给中学生做一个计算器。朱老师没有同时做两个项目，而是打算先做小学生的计算器，之后在小学生计算器的基础上添加一些功能来实现中学生的计算机。为此朱老师写了一个给小学生用的计算器（里面实现了加减乘除运算），朱老师把这个给小学生用的计算器称为“计算器1.0”，之后呢朱老师又向这个计算器里添加了sin、cos计算和虚数运算，这样就可以给中学生用了，朱老师将增加功能后的计算器称为“计算器2.0”。噔噔，朱老师实现了计算器的版本更新。</p>
<p>那么，请聪明的wxy想一想，在上面这个故事里有没有隐藏着什么问题呢？</p>
<p>如果朱老师觉得中学生很厉害，什么数的加法都应该可以口算出来，根本不需要使用计算器来计算加法，把计算器2.0中的加法功能去除了怎么办，这样就导致了一个问题：就是在低版本里拥有的功能在高版本里反而没有了。这样就会产生<strong>版本冲突</strong>，那就是<em>使用高版本的用户</em>想使用<em>低版本的功能</em>时发现无法使用。其实版本冲突的含义远不止这些，但从上面这个例子就可以看出，软件版本这个概念非常重要，直接关系到软件能否正常运行。</p>
<p><img src="/images/版本冲突.png" /></p>
<p>为此，Anaconda提供了一个解决方案:以项目为管理单位，每个项目使用自己要使用的软件版本，项目与项目之间相互独立，互不冲突，甚至每个项目使用的python版本也不同（python也是会有版本迭代的，只要是软件都会有，没有人能一开始就做的尽善尽美）。这样，python的使用者就可以使用不同版本的python乃至python库了（之后再介绍python库是什么）。</p>
<h3 id="vscode的安装">VSCode的安装</h3>
<p>VSCode是一个集成开发环境（Integrated Development
Environment）。集成开发环境是什么？</p>
<p>实际开发中，我们往往需要很多其他辅助软件来帮助我们写代码，例如：</p>
<p>编辑器：用来编写代码，并且给代码着色，以方便阅读；</p>
<p>代码提示器：输入部分代码，即可提示全部代码，加速代码的编写过程；</p>
<p>调试器：观察程序的每一个运行步骤，发现程序的逻辑错误；</p>
<p>项目管理工具：对程序涉及到的所有资源进行管理，包括源文件、图片、视频、第三方库等；</p>
<p>漂亮的界面：各种按钮、面板、菜单、窗口等控件整齐排布，操作更方便。</p>
<p>这些工具通常被打包在一起，统一发布和安装，你可以把它想象为一个word，可以让你更方便地编写代码，</p>
<p>而VSCode就是这样一个集成开发环境，它相比于其他的集成开发环境更加轻便。</p>
<hr />

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://morandave.github.io/2023/11/30/%E8%8A%82%E7%82%B9%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="moran">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="斋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/30/%E8%8A%82%E7%82%B9%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">节点类的实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-30 21:11:21" itemprop="dateCreated datePublished" datetime="2023-11-30T21:11:21+08:00">2023-11-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-18 18:14:50" itemprop="dateModified" datetime="2024-01-18T18:14:50+08:00">2024-01-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/deep-learning-framework/" itemprop="url" rel="index"><span itemprop="name">deep learning framework</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="节点类综述">节点类综述</h2>
<p>节点类是一个抽象类，体现不同节点之间差异的是两个抽象方法，<code>compute()</code>和<code>get_jacobi(父节点)</code>方法，<code>compute</code>方法实现了节点的正向传播，根据父节点parents的值计算本节点的值；<code>get_jacobi</code>则是针对某个特定的父节点来计算本节点对某个父节点的雅可比矩阵。</p>
<p>细节概念：a对b的雅可比矩阵： <span class="math display">\[
\frac{ {\partial a} } { {\partial b}}
\]</span></p>
<h2 id="节点类的共同部分">节点类的共同部分</h2>
<h3 id="节点类的属性">节点类的属性</h3>
<p><code>jacobi</code>：最终结果对节点的雅可比矩阵
<code>result</code>：结果节点 <code>parents</code>：父节点</p>
<h3 id="节点类的方法">节点类的方法</h3>
<p><code>forward</code>：前向传播计算本节点的值，若父节点的值未被计算，则递归调用父节点的forward方法</p>
<p><code>backward</code>
：反向传播，计算结果节点对本节点的雅可比矩阵</p>
<h2 id="反向传播的实现">反向传播的实现</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self, result</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    计算结果节点对本节点的雅可比矩阵</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> self.jacobi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">		<span class="keyword">if</span> self <span class="keyword">is</span> result:</span><br><span class="line">           self.jacobi = np.mat(np.eye(self.dimension()))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.jacobi = np.zeros((result.dimension(),self.dimension()))</span><br><span class="line">            <span class="keyword">for</span> child <span class="keyword">in</span> self.get_children():</span><br><span class="line">                <span class="keyword">if</span> child.value <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    self.jacobi += child.backward(result) * child.get_jacobi(self)</span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<hr />

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://morandave.github.io/2023/07/28/%E5%AD%A6%E6%A0%A1%E5%A4%8F%E4%BB%A4%E8%90%A5%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="moran">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="斋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/28/%E5%AD%A6%E6%A0%A1%E5%A4%8F%E4%BB%A4%E8%90%A5%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">学校夏令营总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-28 17:49:20" itemprop="dateCreated datePublished" datetime="2023-07-28T17:49:20+08:00">2023-07-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-30 10:59:42" itemprop="dateModified" datetime="2023-11-30T10:59:42+08:00">2023-11-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Conclusion/" itemprop="url" rel="index"><span itemprop="name">Conclusion</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="干了什么事">干了什么事</h1>
<p>第一周看了b站李宏毅的机器学习课程，内容非常多，看的效果不好，接收到的东西有限</p>
<p>第二周前4天在学长的指导下看了b站小土堆的pytorch入门视频，视频质量很高，尤其是其中穿插的Pycharm操作非常实用，，同时学习了Pytorch的基本编程概念，小土堆读官方文档的能力很强，应该培养像他一样的能力</p>
<p>第二周后3天看了Attention is all you
need这篇论文，了解了自注意力机制和Transformer。发现了一些读论文的工具，比如chatpaper可以自动翻译和概括论文的内容。同时发现了一个博主在github把许多论文的讲解放在一个仓库里，最重要的是他整理了数据在模型中的变化。</p>
<h1 id="机器学习关于模型的那些事">机器学习关于模型的那些事</h1>
<p>模型的能力与数据集的复杂度是对立的两个元素，二者需要相互匹配才能训练出好的结果：
模型能力强而数据集简单会导致过拟合；
模型能力弱而数据集复杂会导致欠拟合；</p>
<p>模型被分为两种：Regression和Classification</p>
<h1 id="梯度下降法">梯度下降法</h1>
<p>整个模型就是一个函数，函数里面一定会有参数，比如 <span
class="math display">\[
y=mx^2
\]</span>
x的平方前面的m就是函数的参数，x对应的是模型的输入（比如CNN的输入是图片），而当x确定下来的时候，m是个变量，我们可以求m对y的导数，如果导数为负数，那么就将m增大一点，如果导数为正数，那就将m减小一点。这样我们就可以让m往使y变小的方向变化，这便是梯度下降法的最简单形式。那么y是什么呢，y是损失函数Loss，Loss越小，模型的判断能力越强，也就是说梯度下降法可以让m往使损失函数变小/模型判断能力变强的方向变化。</p>
<p>不知道为什么不能提交了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="moran"
      src="/images/head.png">
  <p class="site-author-name" itemprop="name">moran</p>
  <div class="site-description" itemprop="description">选择有时候比努力更重要</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2023-06 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">moran</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


</body>
</html>
